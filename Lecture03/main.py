########################################################################################
### Ускоренная обработка данных: lambda, filter, map,zip, enumerate, List, Comprehension 
########################################################################################
## Анонимные, lambda функции 
##############################

# def sum(x):
#  return x+10
# sum = lambda x: x+10
# # def mult(x):
# #  return x**2
# mult = lambda x: x**2
# # sum(mult(2))

# # def sum1(x):
# #  return x+22
# sum1 = lambda x: x+22
# # def mult2(x):
# #  return x**3
# mult2 = lambda x: x**3
# # sum1(mult2(2))

# # def sum3(x):
# #  return x+242
# sum4 = lambda x: x+242
# # def mult4(x):
# #  return x**5
# mult4 = lambda x: x**5
# # sum3(mult2(2))

############################

# def f(x):
#     x**2
# g = f
# print(f(1))    #   вызываем  f  передаём туда аргументы
# print(g(21))   #    вызываем  g

##############################

# def f(x):
#     return x**2
# g = f
# # print(type(f))
# print(type(g))

# print(f(4))
# print(g(4))

###############################

# def calc1(x):
#     return x+10
# print (calc1(10))

# def calc2(x):
#     return x*10
# # print (calc2(10))

# def math(op, x):
#     print(op(x))

# math(calc2, 10)
# math(calc1, 10)

###################################
# пример функции с 2 переменными
###################################

# def sum(x, y):
#  return x+y

# sum = lambda x, y: x+y
# def mult(x, y):
#  return x*2

# def calc(op, a, b):
#     print(op(a, b))
#     # return op(a, b)
# calc(lambda x, y: x+y, 4, 5)

#################################

# sum = lambda x: x+10
# mult = lambda x: x**2
# sum(mult(2))

# sum1 = lambda x: x+22
# mult2 = lambda x: x**3
# sum1(mult2(2))

# sum4 = lambda x: x+242
# mult4 = lambda x: x**5
# sum3(mult2(2))

# f(g(x))
# def h(f, g, x): return f(g(x))h = lambda f, g, x: f(g(x))
# h(sum, mult, 5)
# h(lambda x: x+10, lambda x: x**2, 5)

###########################################
## List Comprehension
###########################################

# [exp for item in iterable]
# [exp for item in iterable (if conditional)]
# [exp <if conditional> for item in iterable (if conditional)]

#############################

# list = []
# for i in range(1, 21):
#     # if (i%2==0):
#         list.append(i);

# print(list)     # [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

# list = [i for i in range(1, 11)]   
# print(list)  #  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

# list = [(i, i) for i in range(1, 7) if i % 2 == 0]
# print(list)  #  кортеж  [(2, 2), (4, 4), (6, 6)]

# def f(x):
#     return x**3
# list = [f(i) for i in range(1, 11) if i % 2 == 0]
# print(list)  #  [8, 64, 216, 512, 1000]

# def f(x):
#     return x**3
# list = [(i, f(i)) for i in range(1, 11) if i % 2 == 0]
# print(list)  #  кортеж [(2, 8), (4, 64), (6, 216), (8, 512), (10, 1000)]

############################
#  В файле хранятся числа, 
# нужно выбрать четные и составить список пар (число; квадрат числа). 
# Пример: 1 2 3 5 8 15 23 38
# Получить: [(2, 4), (8, 64), (38, 1444)]
############################

# path ='/Users/Иван/Desktop/GeekBrains/Python/Lecture003/file.txt'
# f = open(path, 'r')
# data = f.read() + ' '
# f.close()

# numbers = []

# while data != ' ':
#     space_pos = data.index(' ')
#     numbers.append(int(data[:space_pos]))
#     data = data[space_pos+1:]

# out = []
# for e in numbers:
#     if not e % 2:
#         out.append((e, e**2))
# print(out)

#################################

# def select(f, col): # описываем функцию (select) которая принимает функцию (col) и некоторый набор данных
#     return[f(x)for x in col]  # далее формируем новый список и сразу его возвращаем
# def where(f,col):  # описываем функцию where которая принимает функцию (col) и некоторый набор данных
#     return[x for x in col if f(x)]  # далее  возвращаем некий список
# data = '1 2 33 5 8 15 23 38'.split()  # далее  берём готовую строку и приминяем к ней функцию (split)
# res = select(int, data)  
# #  сохраняем результат в некий список (list), в качестве 1 аргумента (int), а в качестве набора данных (data)
# # в (result) положим результат работы ф-ии (where), где в качестве аргумента пробрасываем функцию делающую проверку на четность
# # описываем (lambda) которая проверяет для каждого (x) и возвращать результат для чётных чисел
# # в качестве 2 аргумента передаём результат работы на предидущем этапеБ ожидаем получить только список чётных чисел
# res = where(lambda x: not x%2, res) 
# # берём (result) вызываем ф-ию (select) где в качестве 2 аргумента передадим результат работы на предидущем этапе
# # в качестве функции передадиим (lambda) принимающую (x) и возвращающую кортеж (x, x**2)
# res = select(lambda x:(x, x**2), res) 
# print(res)  #  [(2, 4), (8, 64), (38, 1444)]

##################################################################
## Функция map() применяет указанную функцию к каждому элементу
#  итерируемого объекта и возвращает итератор с новыми объектами.
##################################################################

# f(x) ⇒ x + 10
# map(f, [ 1, 2, 3, 4, 5])
#          ↓  ↓  ↓  ↓  ↓
#        [11,12,13,14,15]

# li = [x for x in range(1,20)]
# li = list(map(lambda x:x+10, li))
# print (li)

###################################

# data = list(map(int, input().split()))  # 2  3 4 55 6
# print(data)  # [2, 3, 4, 55, 6]
###################################

# # data = map(int, input().split()) # для ручного ввода
# data = list(map(int,'1 2 3 4 555 6'.split()))
# for e in data:
#     print(e*10) # 20 30 40 5550 60
# print('--')
# for e in data:
#     print(e) 

####################################

# def where(f,col):  # 
#     return[x for x in col if f(x)]  # 
# data = '1 2 33 5 8 15 23 38'.split()  # 
# res = map(int, data)  
# res = where(lambda x: not x%2, res) 
# res = list(map(lambda x:(x, x**2), res)) 
# print(res)  #  [(2, 4), (8, 64), (38, 1444)]

########################################################################################
## Функция filter() применяет указанную функцию к каждому элементу итерируемого объекта и
# возвращает итератор с теми объектами, для которых функция вернула True.
#########################################################################################
# f(x) ⇒ x - чётное
# filter(f, [ 1, 2, 3, 4,5])
#                     ↓
#               [ 2, 4 ]
#######################################################################

# data = [x for x in range(10)]
# res = list(filter(lambda x: x%2==0, data))
# print(res)

###########################################

# data = '1 2 33 5 8 15 23 38'.split()
# res = map(int, data)  
# res = filter(lambda x: not x%2, res) 
# res = list(map(lambda x:(x, x**2), res)) 
# print(res)  #  [(2, 4), (8, 64), (38, 1444)]

###################################################################
# Функция zip() применяется к набору итерируемых объектов и возвращает
#  итератор с кортежами из элементов входных данных.
# Количество элементов в результате равно минимальному количеству 
# элементов входного набора

# zip ([1, 2, 3], [ ‘о‘, ‘д‘, ‘т‘], [‘f’,’s’,’t’])
#  ↓
# [(1, 'о', 'f'), (2, 'д', 's'), (3, 'т', 't')]
#############################################

# users = ['user1','user2', 'user3', 'user4', 'user5']
# ids = [4, 5, 9, 14, 7]
# salary = [111, 222, 333]
# data = list(zip(users, ids, salary)) #  (salary) - входной эл-т условных зарплат
# #  список из 3 кортежей 
# print(data)  # [('user1', 4, 111), ('user2', 5, 222), ('user3', 9, 333)]

####################################################################
# Функция enumerate() применяется к итерируемому объекту и возвращает
#  новый итератор с кортежами из индекса и элементов входных данных.
# ####################################################################

# enumerate(['Казань', 'Смоленск', 'Рыбки', 'Чикаго'])
#  ↓
# [(0, 'Казань'), (1, 'Смоленск'), (2, 'Рыбки'), (3, 'Чикаго')]

#########################################

users = ['user1','user2', 'user3', 'user4', 'user5']
ids = [4, 5, 9, 14, 7]
salary = [111, 222, 333]
data = list(enumerate(users))

print(data) # [(0, 'user1'), (1, 'user2'), (2, 'user3'), (3, 'user4'), (4, 'user5')]